=== JRecordBind ===

A tiny and super fast library and code generator that aims to

    * map fixed-length lines to bean instances, ready to be chewed by an import procedure (Unmarshaller)
    * and export record beans into a fixed-length file (Marshaller).

Why?

Almost everybody has written an import procedure of some sort: the customer is always filling your email box with data to import and that he doesn't want to manually type, despite your cool web interface.

Fixed-length are a must for every public institution (at least in Italy): regardless of the age of the destination system, everyone can read a plain text file

JRecordBind aims to leverage the boring parsing task and let the developer focus on real problems: understanding the data and find an easy way to feed the persistence layer.
Advantages

JRecordBind is (AFAIK) the only tool aimed at fixed-length files that's able to marshall and unmarshall. By the way you may be a producer of fixed length files, not just a consumer.

JRecordBind supports hierarchical fixed length files: records of some type that are "sons" of other record types.

JRecordBind uses XML Schema for the definition file: that could make your learning curve steeper.
Where?

Downloads are available from the download section

The latest STABLE release of JRecordBind-2 is 90

If you need support, drop an email. If you have found a bug, file it! file it now!
Should I care?

If you are a software developer, yes, you should. At least you should remind the existence of JRecordBind, for the time some customer of yours will ask you to "import this file from our host"
How it works?
Record definition

When you need to import a fixed-length file, someone has given you a wide documentation regarding how the file is structured: each field, its length, its value and how to convert it.

JRecordBind needs that specification: it's the starting point. You need to map the documentation into a file. Here's an example:

<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://schemas.assist-si.it/jrb/simple" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://schemas.assist-si.it/jrb/simple" xmlns:jrb="http://jrecordbind.dev.java.net/2/xsd" elementFormDefault="qualified" attributeFormDefault="unqualified">
  <xs:complexType name="SimpleRecord">
    <xs:sequence>
      <xs:element name="name" type="xs:string" jrb:length="20"/>
      <xs:element name="surname" type="xs:string" jrb:length="20"/>
      <xs:element name="taxCode" type="xs:string" jrb:length="16"/>
      <xs:element name="birthday" type="xs:date" jrb:length="8" jrb:converter="it.assist.jrecordbind.test.SimpleRecordDateConverter"/>
      <xs:element name="oneInteger" type="xs:int" jrb:length="2"/>
      <xs:element name="oneFloat" type="xs:float" jrb:length="3" jrb:converter="it.assist.jrecordbind.test.SimpleRecordFloatConverter"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="main" type="SimpleRecord" jrb:length="100"/>
</xs:schema>

It's a standard XML Schema file (xsd) plus some custom attributes and a mandatory "main" element.
The "main" element will be the starting point, the main bean JRecordBean will (un)marshall.
The custom attributes are:
ATTRIBUTE 	SCOPE 	MEANING
jrb:length 	"main" element 	it's the total length of the fixed length file
jrb:length 	single elements 	the length of that particular field
jrb:delimiter 	"main" element 	what delimits each field
jrb:padder 	"main" element 	the default padder when not specified
jrb:padder 	single elements 	a custom padder for that field
jrb:converter 	single elements 	how to convert that field to/from a string: there're some defaults
jrb:row 	single elements 	if a bean is split into more than one row, from the second row on, you need to specify the current row number (zero based)

When you are ready with your definition, generate the beans. Here's the ant target

<target name="regenerate">
	<taskdef name="xjc" classname="com.sun.tools.xjc.XJCTask">
		<classpath refid="classpath" />
	</taskdef>

	<xjc destdir="${src.gen}" binding="bindings.xjb.xml">
		<schema dir="${src.test}" includes="*.def.xsd" />
	</xjc>
</target>

You are now ready to (un)marshall your fixed length files
Unmarshaller

Given an fixed-length text file, honoring the definition, for example

WALTER              LIPPMANN            ABCDEF79D18K999A1889092381197
DAVID               JOHNSON             ABCDEF79E18S999B1889092381197

you can call the unmarshaller this way:

Unmarshaller<SimpleRecord> unmarshaller = new Unmarshaller<SimpleRecord>(new InputStreamReader(SimpleRecordUnmarshallTest.class.getResourceAsStream("/simple.def.xsd")));

Iterator<SimpleRecord> iter = unmarshaller.unmarshall(new InputStreamReader(SimpleRecordUnmarshallTest.class.getResourceAsStream("simple_test.txt")));

assertTrue(iter.hasNext());
SimpleRecord record = iter.next();
assertEquals("JOHN                ", record.getName());
assertEquals("SMITH               ", record.getSurname());
assertEquals("ABCDEF88L99H123B", record.getTaxCode());

The presence of an Iterator assure you a very small memory footprint.
Marshaller

Given a record bean full of data, you write:

//some bean taken somewhere
SimpleRecord record = new SimpleRecord();
record.setName("WALTER");
[...]

//setting up the marshaller
Marshaller<SimpleRecord> marshaller = new Marshaller<SimpleRecord>(new InputStreamReader(SimpleRecordMarshallTest.class.getResourceAsStream("/simple.def.xsd")));

//setting up the destination Writer
Writer writer = new StringWriter();

//marshalling
marshaller.marshall(record, writer);
System.out.println(writer.toString());

and get the original input back
Examples
Take a look the .xsd files used as tests: they are in the repository