<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<body>
<h2>=== JRecordBind ===</h2>
<p>A tiny and super fast library that aims to</p>
<ul>
	<li>map fixed-length lines to bean instances, ready to be chewed by an import procedure (Unmarshaller)</li>
	<li>and export record beans into a fixed-length file (Marshaller).</li>
</ul>
<style>
pre {
	overflow: auto;
	background: rgb(230, 230, 230);
	border: solid;
	border-width: thin;
	padding: 5px 10px;
	font-size: 8pt;
}

/* 
Title: Eclipse
Author: Luigi R. Viggiano
Copyright (c) 2006 NewInstance.it 
*/
pre.java span.string_constant {
	color: #2a00ff;
}

pre.java span.char_constant {
	color: #990000;
}

pre.java span.numeric_constant {
	color: #990000;
}

pre.java span.parenthesis {
	color: #000000;
}

pre.java span.code {
	color: #000000;
}

pre.java span.java_keyword {
	color: #7f0055;
	font-weight: bold;
}

pre.java span.java_primitive_type {
	color: #7f0055;
	font-weight: bold;
}

pre.java span.java_annotation {
	color: #646464;
}

pre.java span.comment_block {
	color: #3f7f5f;
}

pre.java span.comment_line {
	color: #3f7f5f;
}

pre.java span.comment_task_tag {
	color: #7f9fbf;
	font-weight: bold;
}

pre.java span.javadoc {
	color: #3f5fbf;
}

pre.java span.javadoc_keyword {
	color: #7f9fbf;
	font-weight: bold;
}

pre.java span.javadoc_html_tag {
	color: #7f7f9f;
}

pre.java span.line_number {
	padding-right: 5px;
	padding-top: 1px;
	margin-right: 2px;
	border-right: 1px solid #ddd;
	font-style: normal;
	color: #777;
}
</style>
<h3>Why?</h3>
<p>Almost everybody has written an import procedure of some sort: the customer is always filling your email box with data to import and that he doesn't want to manually type, despite your cool web interface.</p>
<p>Fixed-length are a must for every public institution (at least in Italy): regardless of the age of the destination system, everyone can read a plain text file</p>
<p>JRecordBind aims to leverage the boring parsing task and let the developer focus on real problems: understanding the data and find an easy way to feed the persistence layer.</p>
<h3>Advantages</h3>
<p>JRecordBind is (AFAIK) the only tool aimed at fixed-length files that's able to <strong>marshall and unmarshall</strong>. By the way you may be a producer of fixed length files, not just a consumer.</p>
<p>JRecordBind supports <strong>hierarchical</strong> fixed length files: records of some type that are "sons" of other record types.
<p>JRecordBind uses <strong>XML Schema</strong> for the definition file: that could make your learning curve steeper.</p>
<h3>Where?</h3>
<p>Downloads are available from the <a href="https://jrecordbind.dev.java.net/servlets/ProjectDocumentList?folderID=9627&expandFolder=9627&folderID=9627">download section</a></p>
<p>The latest <strong>STABLE</strong> release of JRecordBind-2 is <strong>93</strong> (version 2.1)</p>
<p>If you need support, <a href="mailto:fridrik@dev.java.net">drop an email</a>. If you have found a bug, <a href="https://jrecordbind.dev.java.net/servlets/ProjectIssues">file it! file it now!</a></p>
<h3>Should I care?</h3>
<p>If you are a <strong>software developer</strong>, <strong>yes</strong>, you should. At least you should remind the existence of JRecordBind, for the time some customer of yours will ask you to "import this file from our host"</p>
<h3>How it works?</h3>
<h4>Record definition</h4>
<p>When you need to import a fixed-length file, someone has given you a wide documentation regarding how the file is structured: each field, its length, its value and how to convert it.</p>
<p>JRecordBind needs that specification: it's the starting point. You need to map the documentation into an XSD file. Here's an example:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema targetNamespace="http://schemas.assist-si.it/jrb/simple" xmlns:xs="http://www.w3.org/2001/XMLSchema" 
	xmlns="http://schemas.assist-si.it/jrb/simple" xmlns:jrb="http://jrecordbind.dev.java.net/2/xsd" 
	elementFormDefault="qualified" attributeFormDefault="unqualified"&gt;
  &lt;xs:complexType name="SimpleRecord"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="name" type="xs:string" jrb:length="20"/&gt;
      &lt;xs:element name="surname" type="xs:string" jrb:length="20"/&gt;
      &lt;xs:element name="taxCode" type="xs:string" jrb:length="16"/&gt;
      &lt;xs:element name="birthday" type="xs:date" jrb:length="8" jrb:converter="it.assist.jrecordbind.test.SimpleRecordDateConverter"/&gt;
      &lt;xs:element name="oneInteger" type="xs:int" jrb:length="2"/&gt;
      &lt;xs:element name="oneFloat" type="xs:float" jrb:length="3" jrb:converter="it.assist.jrecordbind.test.SimpleRecordFloatConverter"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:element name="main" type="SimpleRecord" jrb:length="100"/&gt;
&lt;/xs:schema&gt;
</pre>
<p>It's a standard XML Schema file (xsd) plus some custom attributes and a mandatory "main" element.<br />
The "main" element will be the starting point, the main bean JRecordBean will (un)marshall.<br />
The custom attributes are:
<table border="1">
	<tr>
		<td><strong>ATTRIBUTE</strong></td>
		<td><strong>SCOPE</strong></td>
		<td><strong>MEANING</strong></td>
		<td><strong>MANDATORY</strong></td>
	</tr>
	<tr>
		<td>jrb:length</td>
		<td>"main" element</td>
		<td>it's the total length of the fixed length file</td>
		<td>Yes. Can be omitted to obtain dynamic length files, if the "delimiter" attribute is specified</td>
	</tr>
	<tr>
		<td>jrb:length</td>
		<td>single elements</td>
		<td>the length of that particular field</td>
		<td>Yes. Can be omitted if the file has dynamic length</td>
	</tr>
	<tr>
		<td>jrb:delimiter</td>
		<td>"main" element</td>
		<td>what delimits each field</td>
		<td>No. It becomes mandatory only if you need dynamic length files</td>
	</tr>
	<tr>
		<td>jrb:padder</td>
		<td>"main" element</td>
		<td>the default padder when not specified</td>
		<td>No. JRecordBind will use its default (see the javadoc)</td>
	</tr>
	<tr>
		<td>jrb:padder</td>
		<td>single elements</td>
		<td>a custom padder for that field</td>
		<td>No. JRecordBind will use its default (see the javadoc)</td>
	</tr>
	<tr>
		<td>jrb:converter</td>
		<td>single elements</td>
		<td>how to convert that field to/from a string: there're some defaults</td>
		<td>No. JRecordBind will use its default (see the javadoc)</td>
	</tr>
	<tr>
		<td>jrb:row</td>
		<td>single elements</td>
		<td>if a bean is split into more than one row, from the second row on, you need to specify the current row number (zero based)</td>
		<td>No. JRecordBind will default it to 0 (the whole record on one line)</td>
	</tr>
</table>
<p>Since version 2.1, you can omit the <strong>jrb:length</strong> attribute while specifying the <strong>jrb:delimiter</strong>: this way you can achieve <strong>dynamic</strong> field length.</p>
<p>When you are ready with your definition, generate the beans. Here's the ant target</p>
<pre>
&lt;target name="regenerate"&gt;
	&lt;taskdef name="xjc" classname="com.sun.tools.xjc.XJCTask"&gt;
		&lt;classpath refid="classpath" /&gt;
	&lt;/taskdef&gt;

	&lt;xjc destdir="${src.gen}" binding="bindings.xjb.xml"&gt;
		&lt;schema dir="${src.test}" includes="*.def.xsd" /&gt;
	&lt;/xjc&gt;
&lt;/target&gt;
</pre>
<p>You are now ready to (un)marshall your fixed length files</p>
<h4>Unmarshaller</h4>
<p>Given an fixed-length text file, honoring the definition, for example
<pre>WALTER              LIPPMANN            ABCDEF79D18K999A1889092381197
DAVID               JOHNSON             ABCDEF79E18S999B1889092381197
</pre>
<p>you can call the unmarshaller this way:</p>
<pre class="java"><span class="code">Unmarshaller&lt;SimpleRecord&gt; unmarshaller = <span class="java_keyword">new</span> Unmarshaller&lt;SimpleRecord&gt;<span class="parenthesis">(</span><span class="java_keyword">new</span> InputStreamReader<span class="parenthesis">(</span>
	SimpleRecordUnmarshallTest.<span class="java_keyword">class</span>.getResourceAsStream<span class="parenthesis">(</span><span class="string_constant">&quot;/simple.def.xsd&quot;</span><span class="parenthesis">)))</span>;

Iterator&lt;SimpleRecord&gt; iter = unmarshaller.unmarshall<span class="parenthesis">(</span><span class="java_keyword">new</span> InputStreamReader<span class="parenthesis">(</span>
	SimpleRecordUnmarshallTest.<span class="java_keyword">class</span>.getResourceAsStream<span class="parenthesis">(</span><span class="string_constant">&quot;simple_test.txt&quot;</span><span class="parenthesis">)))</span>;

assertTrue<span class="parenthesis">(</span>iter.hasNext<span class="parenthesis">())</span>;
SimpleRecord record = iter.next<span class="parenthesis">()</span>;
assertEquals<span class="parenthesis">(</span><span class="string_constant">&quot;JOHN                &quot;</span>, record.getName<span class="parenthesis">())</span>;
assertEquals<span class="parenthesis">(</span><span class="string_constant">&quot;SMITH               &quot;</span>, record.getSurname<span class="parenthesis">())</span>;
assertEquals<span class="parenthesis">(</span><span class="string_constant">&quot;ABCDEF88L99H123B&quot;</span>, record.getTaxCode<span class="parenthesis">())</span>;</span></pre>
<p>The presence of an <code>Iterator</code> assure you a very small memory footprint.</p>
<h4>Marshaller</h4>
<p>Given a record bean full of data, you write:</p>
<pre class="java"><span class="code"><span class="comment_line">//some bean taken somewhere</span>
SimpleRecord record = <span class="java_keyword">new</span> SimpleRecord<span class="parenthesis">()</span>;
record.setName<span class="parenthesis">(</span><span class="string_constant">&quot;WALTER&quot;</span><span class="parenthesis">)</span>;
<span class="parenthesis">[</span>...<span class="parenthesis">]</span>

<span class="comment_line">//setting up the marshaller</span>
Marshaller&lt;SimpleRecord&gt; marshaller = <span class="java_keyword">new</span> Marshaller&lt;SimpleRecord&gt;<span class="parenthesis">(</span><span class="java_keyword">new</span> InputStreamReader<span class="parenthesis">(</span>
	SimpleRecordMarshallTest.<span class="java_keyword">class</span>.getResourceAsStream<span class="parenthesis">(</span><span class="string_constant">&quot;/simple.def.xsd&quot;</span><span class="parenthesis">)))</span>;

<span class="comment_line">//setting up the destination Writer</span>
Writer writer = <span class="java_keyword">new</span> StringWriter<span class="parenthesis">()</span>;

<span class="comment_line">//marshalling</span>
marshaller.marshall<span class="parenthesis">(</span>record, writer<span class="parenthesis">)</span>;
System.out.println<span class="parenthesis">(</span>writer.toString<span class="parenthesis">())</span>;</span></pre>
<p>and get the original input back</p>
<h3>How to: different record types</h3>
<p>Hierarchical fixed-length files uses ID fields to differentiate the various records: you'll have something like "Record 000 is the address, record A01 are the vehicles..." and so on.</p>
<p>JRecordBind can easily recognize each record type if you used the xsd "fixed" standard attribute: <a href="https://jrecordbind.dev.java.net/source/browse/jrecordbind/trunk/jrecordbind/test/hierarchical.def.xsd?view=markup" target="_blank">see this example</a></p>
<p>I.E. you are telling JRecordBind that the "recordId" field, of type string and 3 chars long, will always have the "A00" fixed value</p> 
<h3>Examples</h3>
Take a look the .xsd files used as tests: they are in the
<a href="https://jrecordbind.dev.java.net/source/browse/jrecordbind/trunk/jrecordbind/test/">repository</a>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-495755-3");
pageTracker._initData();
pageTracker._trackPageview();
</script>
</body>