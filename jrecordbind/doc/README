=== JRecordBind ===

A tiny and super fast library and code generator that aims to

    * generate beans out of fixed-length (aka "records") files definitions
    * map record lines to bean instances, ready to be chewed by an import procedure (Unmarshaller)
    * export record beans into a fixed-length file (Marshaller)

== Why?

Almost everybody has written an import procedure of some sort: the customer is always filling your email box with data to import and that he doesn't want to manually type, despite your cool web interface.

Fixed-length are a must for every public institution (at least in Italy): regardless of the age of the destination system, everyone can read a plain text file

JRecordBind aims to leverage the boring parsing task and let the developer focus on real problems: understanding the data and find an easy way to feed the persistence layer.

== Where?

The latest version of JRecordBind is available from the download section

If you need support, drop an email. If you have found a bug, file it! file it now!

== Should I care?

If you are a software developer, yes, you should. At least you should remind the existence of JRecordBind, for the time some customer of yours will ask you to "import this file from our host"

== How it works?
Record definition

When you need to import a fixed-length file, someone has given you a wide documentation regarding how the file is structured: each field, its length, its value and how to convert it.

JRecordBind needs that specification: it's the starting point. You need to map the documentation into a file. Here's an example:

classname = it.assist.jrecordbind.test.SimpleRecord

<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://schemas.assist-si.it/jrb/simple" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://schemas.assist-si.it/jrb/simple" xmlns:jrb="http://jrecordbind.dev.java.net/2/xsd" elementFormDefault="qualified" attributeFormDefault="unqualified">
  <xs:complexType name="SimpleRecord">
    <xs:sequence>
      <xs:element name="name" type="xs:string" jrb:length="20"/>
      <xs:element name="surname" type="xs:string" jrb:length="20"/>
      <xs:element name="taxCode" type="xs:string" jrb:length="16"/>
      <xs:element name="birthday" type="xs:date" jrb:length="8" jrb:converter="it.assist.jrecordbind.test.SimpleRecordDateConverter"/>
      <xs:element name="oneInteger" type="xs:int" jrb:length="2"/>
      <xs:element name="oneFloat" type="xs:float" jrb:length="3" jrb:converter="it.assist.jrecordbind.test.SimpleRecordFloatConverter"/>
    </xs:sequence>
  </xs:complexType>
  <xs:element name="main" type="SimpleRecord" jrb:length="100"/>
</xs:schema>

The classname is the fully qualified name of the record bean that will be generated
Each row.0 line contains: the name of the field, its size, its type, and an optional converter

Using the GeneratorTask ant task this way

<taskdef name="jrecordbindgen" classname="it.assist.jrecordbind.gen.GeneratorTask">
  <classpath refid="classpath" />
</taskdef>

<jrecordbindgen destpath="${src.gen}" specfile="${src.test}/simple.def.properties" />

a bean will be generated

package it.assist.jrecordbind.test;

/**
 *  This bean has been generated by JRecordBind. Do NOT modify it!
 */
public class SimpleRecord {

  private String name;

  public String getName() {
    return this.name;
  }

  public void setName(String name) {
    this.name = name;
  }

  private String surname;
  [...]

Unmarshaller

Given an fixed-length text file, honoring the definition, for example

WALTER              LIPPMANN            ABCDEF79D18K999A1889092381197
DAVID               JOHNSON             ABCDEF79E18S999B1889092381197

you can call the unmarshaller this way:

//setting up the unmarshaller
Unmarshaller unmarshaller = new Unmarshaller(definitionReader);
definitionReader.close();

//setting up the unmarshaling-iterator
Iterator records = unmarshaller.unmarshall(fixedFileReader);

//consuming the beans, by unmarshalling each line of the input file
while (records.hasNext()) {
  SimpleRecord record = records.next();
  saveToTheDatabase(record);

}

fixedFileReader.close()

The presence of an Iterator assure you a very small memory footprint.
Marshaller

Given a record bean full of data, you write:

//some bean taken somewhere
SimpleRecord record = new SimpleRecord();
record.setName("WALTER");
[...]

//setting up the marshaller
Marshaller marshaller = new Marshaller(definitionReader);
definitionReader.close();

//setting up the destination Writer
Writer writer = new StringWriter();

//marshaling
marshaller.marshal(record, writer);
System.out.println(writer.toString());

and get the original input back

== Examples
One line bean definition, no separator

classname = com.company.SomeRecord

row.0.someString = 20, String
row.0.someDate = 8, java.util.Date, com.company.MyDateFormatConverter
row.0.someInteger = 2, Integer

One line bean definition, custom separator

classname = com.company.SomeRecord
separator = |

row.0.someString = 20, String
row.0.someDate = 8, java.util.Date, com.company.MyDateFormatConverter
row.0.someInteger = 2, Integer

Multi line bean definition, no separator

classname = com.company.SomeRecord

row.0.someString = 20, String
row.0.someDate = 8, java.util.Date, com.company.MyDateFormatConverter
row.0.someInteger = 2, Integer

row.1.someString = 20, String
row.1.someDate = 8, java.util.Date, com.company.MyDateFormatConverter